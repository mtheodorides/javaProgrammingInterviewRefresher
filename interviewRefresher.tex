\title{Java Programming Interview Crash Course}
\author{
        Michael Theodorides
}
\date{\today}

\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}
\maketitle

\begin{abstract}
This is a quick crash course refresher for Java Programming and Algorithms Interviews.
\end{abstract}

\section{Java Primer}

\subsection{Collections}

\paragraph{Key Methods:} clear()

\subsection{List}

\paragraph{Key Methods:} 
\begin{itemize}
	\item sublist(int fromIndex, int toIndex) : Returns a view of the list from fromIndex (inclusive) to toIndex (exclusive)
\end{itemize}

\subsection{Comparable Interface}
\begin{lstlisting}
public interface Comparable<T> {
	int compareTo(T other); //Returns Negative if other is greater, 0 if equal, Positive if other is less
}
\end{lstlisting}

Integer.compare(int a, int b);

\section{Heaps (Priority Queues)}

\paragraph{Heap Applications:} Use a heap when (1.) all you care about is the largest or smallest elements, and you do not need to support fast lookup, delete, or search operations for arbitrary elements
(2.) you need to compute the k largest or k smallest elements in a collection.

\paragraph{Heap Property:} The key at each node is at least as great (higher priority) as the keys stored at its children.

\paragraph{Heap Operations:}
\begin{itemize}
	\item Insertion: O(log n)
	\item Lookup Max (Highest Priority): O(1)
	\item Delete Max (Highest Priority): O(log n)
	\item Arbitrary Search: O(n)
\end{itemize}

\section{Sorting}

\paragraph{Java Review:}
\begin{itemize}
	\item Sorting Comparable Collections and Arrays: Collections.sort(e), Arrays.sort(a)
	\item Comparable Interface
	\item Comparator Interface
\end{itemize}

\paragraph{Sorting Algorithm Criteria:}
\begin{itemize}
	\item Amount of Data Stored
	\item Available Memory (Does data fit into memory?)
	\item Partially Sorted Data
	\item In-Place Algorithm: Sorts data without any additional memory
	\item Stable Algorithm: Preserves the relative order of data elements that are otherwise identical for sorting purposes.
\end{itemize}

\paragraph{Comparision Algorithms:} Sorting algorithms that only require that there is a way to determine whether one key is less than, equal to, or greater than another key.
\begin{itemize}
	\item No comparison algorithm can have a more optimal worst-case running time than O(n log(n)).
\end{itemize}

\paragraph{Selection Sort:}
Algorithm: Start with the first element in the array and scan through the array to find the element with the smallest key to swap with the first element. Repeat the process with each subsequent element until the last element is reached.
\begin{itemize}
	\item Running-Time: \(O(n^2) \)(Best, Average, Worst-Case)
	\item Advantage: Requires at most n-1 swaps (good when moving elements is more expensive than comparing them); In-Place; Maybe Stable
\end{itemize}

\paragraph{Insertion Sort:}
Algorithm: Build a sorted array one element at a time by comparing each new element to the already-sorted elements and inserting the new element into the correct location.
\begin{itemize}
	\item Running-Time: \(O(n^2) \)(Average, Worst-Case), \(O(n) \) (Best-Case)
	\item Advantage: Efficient way to add new elements to a presorted list; Stable, In-Place, Suitable for Small Sets
\end{itemize}


\paragraph{Loop Join Intersection:} Loop through the smaller list and binary search through the second list (if second list is sorted).

\paragraph{Concurrent Intervals Problem:} Sort by Interval Start/End Times; Increment Counter on Start; Decrement Counter on End (Also: Peak Bandwidth Problem)

\bibliographystyle{abbrv}
\bibliography{main}

\end{document}
This is never printed