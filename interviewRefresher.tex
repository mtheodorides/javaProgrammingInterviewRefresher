\title{Java Programming Interview Crash Course}
\author{
        Michael Theodorides
}
\date{\today}

\documentclass[12pt]{article}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document}
\maketitle

\begin{abstract}
This is a quick crash course refresher for Java Programming and Algorithms Interviews.
\end{abstract}

\section{Java Primer}

\subsection{Collections}

\paragraph{Key Methods:} clear()

\subsection{List}

\paragraph{Key Methods:} 
\begin{itemize}
	\item sublist(int fromIndex, int toIndex) : Returns a view of the list from fromIndex (inclusive) to toIndex (exclusive)
\end{itemize}

\subsection{Comparable Interface}
\begin{lstlisting}
public interface Comparable<T> {
	int compareTo(T other); //Returns Negative if other is greater, 0 if equal, Positive if other is less
}
\end{lstlisting}

\subsection{Comparator Interface}
\begin{lstlisting}
public interface Comparator<T> {
	int compare(T first, T second); //Returns Negative if second is greater, 0 if equal, Positive if second is less
}
\end{lstlisting}

\subsection{Sorting}
\begin{itemize}
	\item Arrays.sort(a), Collections.sort(a) //a is comparable
	\item Arrays.sort(a, cmp), Collections.sort(a, cmp) //cmp is a comparator
\end{itemize}

\subsection{Priority Queue (Heap)}
\begin{itemize}
	\item Comparable Constructor: new PriorityQueue<>();
	\item Comparator Constructor: new PriorityQueue<>(int initialSize, Comparator cmp);
	\item Main Operations: add(elem), peek(), poll() //removes min
\end{itemize}

Integer.compare(int a, int b);

\section{Heaps (Priority Queues)}

\paragraph{Heap Applications:} Use a heap when (1.) all you care about is the largest or smallest elements, and you do not need to support fast lookup, delete, or search operations for arbitrary elements
(2.) you need to compute the k largest or k smallest elements in a collection.

\paragraph{Heap Property:} The key at each node is at least as great (higher priority) as the keys stored at its children.

\paragraph{Heap Operations:}
\begin{itemize}
	\item Insertion: O(log n)
	\item Lookup Max (Highest Priority): O(1)
	\item Delete Max (Highest Priority): O(log n)
	\item Arbitrary Search: O(n)
\end{itemize}

\section{Sorting}

\paragraph{Java Review:}
\begin{itemize}
	\item Sorting Comparable Collections and Arrays: Collections.sort(e), Arrays.sort(a)
	\item Comparable Interface
	\item Comparator Interface
\end{itemize}

\paragraph{Sorting Algorithm Criteria:}
\begin{itemize}
	\item Amount of Data Stored
	\item Available Memory (Does data fit into memory?)
	\item Partially Sorted Data
	\item In-Place Algorithm: Sorts data without any additional memory
	\item Stable Algorithm: Preserves the relative order of data elements that are otherwise identical for sorting purposes.
\end{itemize}

\paragraph{Comparison Algorithms:} Sorting algorithms that only require that there is a way to determine whether one key is less than, equal to, or greater than another key.
\begin{itemize}
	\item No comparison algorithm can have a more optimal worst-case running time than O(n log(n)).
\end{itemize}

\paragraph{Selection Sort:}
Algorithm: Start with the first element in the array and scan through the array to find the element with the smallest key to swap with the first element. Repeat the process with each subsequent element until the last element is reached.
\begin{itemize}
	\item Running-Time: \(O(n^2) \)(Best, Average, Worst-Case)
	\item Advantage: Requires at most n-1 swaps (good when moving elements is more expensive than comparing them); In-Place; Maybe Stable
\end{itemize}

\paragraph{Insertion Sort:}
Algorithm: Build a sorted array one element at a time by comparing each new element to the already-sorted elements and inserting the new element into the correct location.
\begin{itemize}
	\item Running-Time: \(O(n^2) \)(Average, Worst-Case), \(O(n) \) (Best-Case)
	\item Advantage: Efficient way to add new elements to a presorted list; Stable, In-Place, Suitable for Small Sets
\end{itemize}

\paragraph{Quicksort:}
Algorithm: Select a pivot value from the data set and split the set into two subsets: a set that contains all values less than the pivot and a set that contains all values greater than or equal to the pivot.  The pivot/split process is recursively applied to each subset until there are no more subsets to split.
\begin{itemize}
	\item Running-Time: \(O(n^2) \)(Worst-Case), \(O(n log(n)) \) (Best-Case, Average-Case)
	\item For randomly ordered data, the value of the pivot is unrelated to its location, therefore a pivot can be chosen from any location.
	\item Performance is dependent on the choice of pivot value.
	\item Maybe Stable, Maybe In-Place
\end{itemize}

\paragraph{Merge Sort:}
Algorithm: Split the data set into two or more subsets, sorting the subsets, and then merge them together into the final sorted set.
\begin{itemize}
	\item Running-Time:\(O(n log(n)) \) (Best-Case, Average-Case, Worst-Case)
	\item Good choice for data sets that are too large to fit into memory.
	\item O(n) Additional Memory required by Merge Step
	\item Stable, Not In-Place
\end{itemize}


\paragraph{Loop Join Intersection:} Loop through the smaller list and binary search through the second list (if second list is sorted).

\paragraph{Concurrent Intervals Problem:} Sort by Interval Start/End Times; Increment Counter on Start; Decrement Counter on End (Also: Peak Bandwidth Problem)

\section{Recursion}

\paragraph{Arms-Length Recursion:} Short-circuiting the base case by invoking the base case before making a recursive call (saves the last function call).

\paragraph{Permutations:}Compute permutations by splitting array into used and unused sections and swap starting element with current element during recursive calls.
\begin{itemize}
	\item Permutation Process: Picking a letter for a given position and performing the permutation process starting at the next position to the right before coming back to change the letter you just picked.
	\item Algorithm for Strings (Immutable): Maintain an array of boolean values corresponding to the positions of the letters in the input string and use this array to mark letters as used or unused.
	\item O(n) Additional Memory required by Merge Step
	\item Stable, Not In-Place
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{main}

\end{document}
This is never printed